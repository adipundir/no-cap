'use server'

import { NOCAPWalrusService, WalrusFactContent } from '@/lib/walrus-service'
import { revalidatePath } from 'next/cache'

// Simplified fact schema for submission
export interface FactSubmissionData {
  title: string
  description: string
  sources?: Array<{
    url: string
    title: string
    accessedAt: string
  }>
  tags?: string[]
  stakeAmount?: string // Optional ETH stake amount
}

// Response from server action
export interface FactSubmissionResult {
  success: boolean
  walrusBlobId?: string
  contentHash?: string
  factId?: number
  error?: string
}

/**
 * Server action to prepare fact data for Walrus storage
 * This handles the off-chain storage preparation before on-chain submission
 */
export async function prepareFactForWalrus(
  submissionData: FactSubmissionData
): Promise<FactSubmissionResult> {
  try {
    // Validate input data
    if (!submissionData.title?.trim()) {
      return { success: false, error: 'Title is required' }
    }
    
    if (!submissionData.description?.trim()) {
      return { success: false, error: 'Description is required' }
    }
    
    if (submissionData.title.length > 200) {
      return { success: false, error: 'Title must be 200 characters or less' }
    }
    
    if (submissionData.description.length > 10000) {
      return { success: false, error: 'Description must be 10,000 characters or less' }
    }

    // Validate stake amount if provided
    if (submissionData.stakeAmount) {
      const stakeValue = parseFloat(submissionData.stakeAmount)
      if (isNaN(stakeValue) || stakeValue < 0) {
        return { success: false, error: 'Invalid stake amount' }
      }
      // No minimum stake requirement - any amount is allowed
    }

    // Prepare fact content for Walrus storage
    const factContent: WalrusFactContent = {
      factId: 0, // Will be updated after on-chain creation
      version: 1,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      
      // Core content
      title: submissionData.title.trim(),
      description: submissionData.description.trim(),
      summary: submissionData.description.length > 500 
        ? submissionData.description.slice(0, 497) + '...' 
        : submissionData.description,
      
      // Additional data
      sources: submissionData.sources || [],
      media: [], // For future media attachments
      tags: submissionData.tags || [],
      category: 0, // Default category for simplified version
      priority: 1, // Default priority for simplified version
      language: 'en',
      contentType: 'text',
      checksum: '' // Will be generated by NOCAPWalrusService
    }

    // Store content on Walrus
    const walrusResult = await NOCAPWalrusService.storeFact(factContent)

    if (walrusResult.source === 'mock') {
      console.warn('Walrus fallback activated while storing fact', {
        factId: factContent.factId,
        title: factContent.title
      })
    }
    
    // Generate content hash for on-chain integrity verification
    const contentHash = generateContentHash(factContent)
    
    console.log('Fact prepared for Walrus:', {
      walrusBlobId,
      contentHash,
      title: factContent.title,
      category: factContent.category,
      priority: factContent.priority
    })

    // Revalidate relevant pages
    revalidatePath('/feed')
    revalidatePath('/submit')

    return {
      success: true,
      walrusBlobId: walrusResult.blobId,
      contentHash,
      factId: 0 // Will be set after on-chain submission
    }

  } catch (error) {
    console.error('Error preparing fact for Walrus:', error)
    
    return {
      success: false,
      error: error instanceof Error 
        ? error.message 
        : 'Failed to prepare fact for storage'
    }
  }
}

/**
 * Generate content hash for integrity verification
 * This should match the hash generation in the smart contract
 */
function generateContentHash(content: WalrusFactContent): string {
  // Create deterministic hash data (same as contract)
  const hashData = JSON.stringify({
    title: content.title,
    description: content.description,
    sources: content.sources,
    createdAt: content.createdAt,
    category: content.category,
    priority: content.priority
  })
  
  // Simple hash for demo - in production, use proper crypto hash
  let hash = 0
  for (let i = 0; i < hashData.length; i++) {
    const char = hashData.charCodeAt(i)
    hash = ((hash << 5) - hash) + char
    hash = hash & hash // Convert to 32-bit integer
  }
  
  // Convert to hex string with 0x prefix (bytes32 format)
  return '0x' + Math.abs(hash).toString(16).padStart(64, '0')
}

/**
 * Server action to retrieve fact content from Walrus
 */
export async function retrieveFactFromWalrus(
  walrusBlobId: string
): Promise<{ success: boolean; content?: WalrusFactContent; error?: string }> {
  try {
    if (!walrusBlobId?.trim()) {
      return { success: false, error: 'Walrus blob ID is required' }
    }

    const content = await NOCAPWalrusService.retrieveFact(walrusBlobId)
    
    if (!content) {
      return { success: false, error: 'Fact not found in Walrus storage' }
    }

    return { success: true, content }

  } catch (error) {
    console.error('Error retrieving fact from Walrus:', error)
    
    return {
      success: false,
      error: error instanceof Error 
        ? error.message 
        : 'Failed to retrieve fact from storage'
    }
  }
}

/**
 * Server action to batch retrieve multiple facts from Walrus
 */
export async function batchRetrieveFactsFromWalrus(
  walrusBlobIds: string[]
): Promise<{ success: boolean; facts?: (WalrusFactContent | null)[]; error?: string }> {
  try {
    if (!Array.isArray(walrusBlobIds) || walrusBlobIds.length === 0) {
      return { success: false, error: 'Walrus blob IDs array is required' }
    }

    const facts = await NOCAPWalrusService.batchRetrieveFacts(walrusBlobIds)
    
    return { success: true, facts }

  } catch (error) {
    console.error('Error batch retrieving facts from Walrus:', error)
    
    return {
      success: false,
      error: error instanceof Error 
        ? error.message 
        : 'Failed to batch retrieve facts from storage'
    }
  }
}
